[{"content":"从几年前（大概是17年吧）初学 C++ 到不久前，都没理解 位运算 的意义，看别人写的算法或多或少也都有位运算参与，看不懂。这就很令人伤心了，于是决定好好研究一下这个 位运算\n💡 Tips: 由于这篇文章是我的笔记，可能有一些废话，如果你是奔着位运算来的，不希望看过多的废话，请戳 TL; DR, 或者点这里直达二进制运算 或者直达 位运算的奇淫技巧\n历史遗留问题 TL; DR 计算机只认识 二进制 数字，也是基于 二进制 完成计算和其他工作；选择 二进制 的两个原因是存储效率和设计难度\n众所周知，计算机只认 二进制 数 ，所以他是不认我们的十进制数滴，当然也不认什么八进制，十二进制，十六进制，六十进制，blablabla\n虽然某国三进制计算机 Сетунь 认的是三进制，可是你用的不是 C*****，所以就不要想那么多了\n当然，ENIAC 用的是十进制，可你用的也不是 E**** 为什么是二进制 选择二进制当然是有原因的，历史原因不可避免的成为主要原因，但是，在那个寸 bit 寸金的年代里，效率和设计难易程度也直接导致了计算机选择二进制。\n关于效率，这里直接抄 某个知乎老哥 的解释1\n设$r \\in R, r \\gt 0$为进制数，即 $r$进制.\n假如这里有 $n$ 个坑 _ _ _ _ \u0026hellip; _，那么可表示 $m = r^{n}$ 个数. 每个坑可以填 $r$ 种符号，也就是说，每个坑有 $r$ 种状态，$n$ 个坑共有 $s = r \\cdot n$ 种状态.\n前面提到过，那个年代寸 bit 寸金，所以存储效率最高的就是最合适的，用数学语言描述就是：为了表示 $m$ 个数，当 $r$ 为多少时，$s$ 可取得最小值？\n然后就有 $s = \\frac{r}{\\ln (r)} \\ln(m)$\n对 $r$ 求导，可得 $r = e \\approx 2.71828182845904523536\\cdots$ 时，$s$ 取最小值 $e \\cdot \\ln(m)$\n很明显，$r = e$ 是最优情况，但是，$e$进制 的电路很明显是不切实际的，所以，在存储效率方面 三进制 成了最优选择，二进制 次之，然而 二进制 的逻辑运算比 三进制 简单不少（至少是在电路设计上），损失一点存储效率，也算是 鱼与熊掌 吧.\n啥？你问我为什么简单？？鄙人不配，请戳这个，这个，这个 或 这个\n你要是非要我说，我只能扯些淡了\n比如说“道生一，一生二，二生三，三生万物”\n或者说 三进制可以认为 Bool 值有三个，即 真 不知道 假，可是纸带上的控只有打了和没打，不存在不知道打没打（喂，这不是加速度） 或者说 二进制只要高低电平 简单呗，就像我们有十根手指头一样 附个 v2ex 的链接吧 https://v2ex.com/t/114165\n二进制究竟是啥 TL; DR 只通过1或0表示数字, 逢2进1 的计数系统\n那这个 二进制 究竟是个什么东西呢，先从 Wikipedia 抄一段 富有文化气息的高大上的 而且看不懂 的解释：\n二进制（binary）在数学和数字电路中指以2为底数的记数系统，以2为基数代表系统是二进位制的。\n扯这些高大上的东西，就不像是百科全书的样子.jpg\n底数是个啥玩意？既然它扯了，那我们顺着链接点下去，了解一下吧\n进位制的底数（radix， base）是指此进位制中，用于表示数所使用的数字符号（包括0）数量。以目前最常使用的十进制为例，每一位的数字可以从0至9，共10个数字，因此底数为10。\n熟悉吗？熟悉就对了，我们刚刚才提过，所谓 $r$进制 就是每个“坑”需要 $r$ 种状态，$r$ 就是底数\n一个数和它的底数用 $(x)_y$ 表示，如 $(10)_2$ 表 $3$\n底数和数的关系 纸上得来终觉浅 设有正整数 $(x)_b$ , 其中 $b$ 为进制, $d_n$ 表示 x (从左往右) 第 $n$ 位数的值\n可推出 $0 \\le d_n \\lt b, n \\in N$\n那么 $b$进制 数的值为 $d_1b^{n-1} + d_2b^{n-2} + \\cdots + d_nb^0$\n⚠️ 注意: 这里的 $b$ 也可以是负数，分数\u0026hellip; 但是 不能 为 $0$, 原因在于 $0^0$ 不是 $1$, 也就不是 个位\n其第 $n$ 位数分别是 $b^n$位，$b^{n-1}$位，$\\cdots$，$b^1$位，$b^0$位(个位)2\n绝知此事要躬行 以数字 $(100)_{16}$ 为例\n其值应为 $1 \\times 16^{2} + 0 \\times 16^{1} + 0 \\times 16^{0} = 256$\n相应的，$1$ 应该是 $256$位，第一个 $0$ 是 $16$位，第二个 $0$ 是 个位\n解释 我觉得，应该不用解释吧\u0026hellip;\n刚刚举了16进制的例子，现在看看10进制\n比如 $(111)_{10}$\n其值应为 $1 \\times 10^{2} + 1 \\times 10^{1} + 0 \\times 10^{0} = 111$\n是不是，突然就看懂了！\n如果没看懂，想一想小学是不是做过求一个数字十位、个位的题目，那个式子是 $\\text{十位上的数字} \\times 10 + \\text{个位上的数字} \\times 1$\n这个 十位上的数字 和 个位上的数字 分别是 $d_{n-1}$ 和 $d_n$\n再把 其第 $n$ 位数分别是 $b^n$位，$b^{n-1}$位，$\\cdots$，$b^1$位，个位 翻译到十进制中就是\n其第 $n$ 位数分别是 $10^n$位,$10^{n-1}$位, $\\cdots$, $10^1$位, 个位，也就是 个、十、百、千、万 等\n或者，直接利用下面这张表3理解 虽然它是给计量单位的\n所表示的因数就是我们说的 $b^n$，不难看出 $b^n$位 与下面的这些 词头 只不过是有名字和没名字的关系罢了\n所表示的因数 词头名称 词头符号 $10^{24}$ 尧[它] Y $10^{21}$ 泽[它] Z $10^{18}$ 艾[可萨] E $10^{15}$ 拍[它] P $10^{12}$ 太[拉] T $10^{9}$ 吉[咖] G $10^{6}$ 兆 M $10^{3}$ 千 k $10^{2}$ 百 h $10^{1}$ 十 da $10^{-1}$ 分 d $10^{-2}$ 厘 c $10^{-3}$ 毫 m $10^{-6}$ 微 μ $10^{-9}$ 纳[诺] n $10^{-12}$ 皮[可] p $10^{-15}$ 飞[母托] f $10^{-18}$ 阿[托] a $10^{-21}$ 仄[普托] z $10^{-24}$ 么[科托] y 搞明白这个，再看 $d_1b^{n-1} + d_2b^{n-2} + \\cdots + d_nb^0$ 是不是就明白了呢？\n再不明白我也没办法了\n其他一些事 对于负数，只需要加上“$-$”号\n对于小数，$b^0$位右边，令 $n \\lt 0, n \\in Z$ 即可\n回到二进制上 有了上面的一堆废话, 那么我们就知道任何 二进制 的正整数可以表示为 $d_12^{n-1} + d_22^{n-2} + \\cdots + d_n2^0$，这也是 二进制 转换为 十进制 的方式\n由 $0 \\le d_n \\lt b$ 我们可知, 二进制 中每一位上的数只能是 $1$ 或 $0$，也就是常说的 逢二进一\n二进制运算 四则运算 加: $0 + 0 = 0$, $1 + 0 = 1$, $1 + 1 = 10$ $ \\begin{array}{r} 10010101\\\\ +01001011\\\\ \\hline 11100000 \\end{array} $ 减: $0 - 0 = 0$, $1 - 0 = 1$, $10 - 1 = 1$, $1 - 1 = 0$ $ \\begin{array}{r} 10010101\\\\ -01001011\\\\ \\hline 01001010 \\end{array} $ 乘: $0 \\times 0 = 0$, $1 \\times 1 = 1$\n除: $0 \\div 1 = 0$, $1 \\div 1 = 1$\n位运算（位操作） 还是从 Wikipedia 抄一下\n位操作是程序设计中对位数组或二进制数的一元和二元操作。\n利用 位运算 达成目标，相较于 四则运算 使用的资源 更少 , 因此功耗 更低 ，而且速度 更快\n💡 Tips: 下面所有位操作相关的运算使用补码\n取反(NOT 或 ~) 取反是 一元运算符 ，在大多数现代编程语言中使用 ~ 表示. 它会对一个 二进制数 按位做 逻辑非(!) 操作.\n比如，~ 1000 得 0111\n💡 Tips: 对某值取反等于该值的相反数减去一，即 $ ~x = -x - 1$\n⚠️ Warning: 逻辑非(!)并不是取反(~)，绝大多数语言会将 逻辑非 作为布尔值的运算符，而不是位操作\n按位 或(OR, |) 、异或(XOR, ^)、与(AND, \u0026amp;) ⚠️ Warning: 逻辑或(||)、逻辑与(\u0026amp;\u0026amp;) 与 按位或 、 按位与 不同\n它们都得 二元运算符 ，对二进制中每一个位作相应的逻辑操作.\n逻辑或: 两个操作数中任意一个为1，则取1 逻辑异或: 两个操作数中有且仅有一个为1，则取1 逻辑与: 两个操作数都取1，则取1 如上内容的数学等价物（来自 Wikipedia ） 假设${\\displaystyle x\\geq y}$，对于非负整数（好像是原码），按位运算可以被写成如下形式：\n${\\begin{aligned}\\operatorname {NOT} x\u0026=\\sum _{n=0}^{\\lfloor \\log _{2}(x)\\rfloor }2^{n}\\left[\\left(\\left\\lfloor {\\frac {x}{2^{n}}}\\right\\rfloor {\\bmod {2}}+1\\right){\\bmod {2}}\\right]=2^{\\left\\lfloor \\log _{2}(x)\\right\\rfloor +1}-1-x\\\\x\\operatorname {AND} y\u0026=\\sum _{n=0}^{\\lfloor \\log _{2}(x)\\rfloor }2^{n}\\left(\\left\\lfloor {\\frac {x}{2^{n}}}\\right\\rfloor {\\bmod {2}}\\right)\\left(\\left\\lfloor {\\frac {y}{2^{n}}}\\right\\rfloor {\\bmod {2}}\\right)\\\\x\\operatorname {OR} y\u0026=\\sum _{n=0}^{\\lfloor \\log _{2}(x)\\rfloor }2^{n}\\left(\\left[\\left(\\left\\lfloor {\\frac {x}{2^{n}}}\\right\\rfloor {\\bmod {2}}\\right)+\\left(\\left\\lfloor {\\frac {y}{2^{n}}}\\right\\rfloor {\\bmod {2}}\\right)+\\left(\\left\\lfloor {\\frac {x}{2^{n}}}\\right\\rfloor {\\bmod {2}}\\right)\\left(\\left\\lfloor {\\frac {y}{2^{n}}}\\right\\rfloor {\\bmod {2}}\\right)\\right]{\\bmod {2}}\\right)\\\\x\\operatorname {XOR} y\u0026=\\sum _{n=0}^{\\lfloor \\log _{2}(x)\\rfloor }2^{n}\\left(\\left[\\left(\\left\\lfloor {\\frac {x}{2^{n}}}\\right\\rfloor {\\bmod {2}}\\right)+\\left(\\left\\lfloor {\\frac {y}{2^{n}}}\\right\\rfloor {\\bmod {2}}\\right)\\right]{\\bmod {2}}\\right)=\\sum _{n=0}^{\\lfloor \\log _{2}(x)\\rfloor }2^{n}\\left[\\left(\\left\\lfloor {\\frac {x}{2^{n}}}\\right\\rfloor +\\left\\lfloor {\\frac {y}{2^{n}}}\\right\\rfloor \\right){\\bmod {2}}\\right]\\end{aligned}}$ 移位 位移操作是我花了很久才理解的玩意儿，是利用某个 计算器App 的位键盘才大概明白是个啥玩意，最近我才知道有 逻辑移位 和 算式移位 等几种位移（下列图片来自 Wikipedia）\n算术移位: 左移补0，右移补符号位 算术左移4\n算术右移\n逻辑移位: 左右移都补0，因此 逻辑左移 等价于 算术左移 逻辑左移\n逻辑右移\n据 Wikipedia 所说，在类 C 语言和 Python 中，是 逻辑移位 ，但是据我观察，C++ 是 算术移位 ( 使用 GCC g++ 12.2.0)\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { short a = -32768; // 1000 0000 0000 0000 a = (a \u0026gt;\u0026gt; 1); // 1100 0000 0000 0000 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 输出 -16384 return 0; } 关于无符号位移：无符号位移就是不管符号的位移\u0026hellip;它会直接无视符号位，也就是说，它会把一个数字视为 0数字，0 是符号位\n二进制与十进制的转化 二进制 -\u0026gt; 十进制 我们知道二进制可以表示为 $d_12^{n-1} + d_22^{n-2} + \\cdots + d_n2^0$ (参见回到二进制上 一节)，这就是 二进制 转化为 十进制 的基本方法（可称为 按位计数法 ），可是在转换较大的二进制数时，幂运算会把你折磨死，这时，就需要一个 Plan B 了\nPlan B \u0026mdash; 双倍法 这个时候写一段程序说明如何转换会让人愉悦\nPython 1 2 3 4 5 6 def bin_to_dec(n: str) -\u0026gt; int: # return int(n, 2) (bushi) last = 0 for i in n: last = last * 2 + int(i) return last C++ 1 2 3 4 5 6 int bin_to_dec(const string \u0026amp;n) { int last = 0; for (char i : n) last = last * 2 + (i - \u0026#39;0\u0026#39;); return last; } C 1 2 3 4 5 6 7 8 int bin_to_dec(const char* n) { int last = 0; while (*n != \u0026#39;\\0\u0026#39;) { last = last * 2 + (*n - \u0026#39;0\u0026#39;); n++; } return last; } Java 1 2 3 4 5 6 7 8 public final class Bin2Dec { public final static int bin2dec(final String n) { int last = 0; for (char i : n.toCharArray()) last = last * 2 + Character.getNumericValue(i); return last; } } 什——么———？你还是想听人话？\n假设要把 $1011001_2$ 转换为十进制\n1 2 3 4 5 6 7 8 9 10 11 12 13 1. 从它最左边的数开始；在 1011001 中，是第一个 1 2. 每向右移动一位，就计算 2 * 前一次计算得到的值 + 当前位数上的数字 ；在 1011001 中是 第二位 0 : 2 * 1 + 0 = 2 第三位 1 : 2 * 2 + 1 = 5 第四位 1 : 2 * 5 + 1 = 11 第五位 0 : 2 * 11 + 0 = 22 第六位 0 : 2 * 22 + 0 = 44 第七位 1 : 2 * 44 + 1 = 89 ( 其实第一位是 ) 第一位 1 : 2 * 0 + 1 = 1 3. 最后一次计算得到数字就是十进制数 十进制 -\u0026gt; 二进制 十进制转二进制的转换有两种方法比较常见，这里称为 余数短除法 和 降幂法\n余数短除法 还是用一段代码解释吧 :-)\n1 2 3 4 5 6 7 8 9 10 def dec_to_bin(n: int) -\u0026gt; str: if n == 0: return \u0026#34;0\u0026#34; if n \u0026lt; 0: return \u0026#34;-\u0026#34; + dec_to_bin(-n) bin_str: list[str] = [] while n != 0: bin_str.append(str(int(n % 2))) n = (n - (n % 2)) / 2 return \u0026#34;\u0026#34;.join(reversed(bin_str)) 用人话解释：\n1 2 3 1. 将数字除以 2，记下余数，用得到的商减去余数 2. 使用 步骤1 得到的结果重复 步骤1 直至商为 0 3. 将记下的余数逆向连接起来，就是目标二进制数 降幂法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def dec_to_bin(n: int) -\u0026gt; str: bin_str: list[str] = [] power = 0 while n \u0026gt;= 2 ** (power + 1): # 确定最大幂 power += 1 while power \u0026gt;= 0: # 降幂 print(n) if n - 2 ** power \u0026lt; 0: bin_str.append(\u0026#34;0\u0026#34;) else: n -= 2 ** power bin_str.append(\u0026#34;1\u0026#34;) power -= 1 return \u0026#34;\u0026#34;.join(bin_str) 人话就是\n1 2 3 4 5 1. 令 f(x) = 2 ^ x 2. 求出 f(x) 不超过十进制数的最大值 3. 从 x = 0 开始列表直到为步骤 2. 中的值（x是自然数） 4. 将待转换数字与最大值做差，再与小于此次差的最大值做差，重复，直到为0 5. 在表格中减数的下方写上1，其他地方写上0，就是答案 原码、反码和补码 咱这会用尽可能通俗的方式介绍这三个玩意，如果有更多的求知欲，可以去 Wikipedia 上阅读，戳这可直达 原码 的 Wikipedia 页面\n原码 原，就是原，没有改变的码，就是原码（暴论\n也就是说，原码表示为 符号 + 数值 的形式；举个例子：11 原码: +1011；-11 原码: -1011\n第一位可以表示符号，正数0负数1，最后就变成了 01011 和 11011\n原码的好处是显而易见的，那就是，能第一眼看到数值，坏处也是显而易见的，它不能直接参与运算\n反码 反，就是反，在原码的基础上反过来，就是反码（暴论\n这个反，意思是按位取反，对于负数，在原码的基础上，对表示数值的位按位取反，得到的就是反码\n打个比方，-11 的原码是 11011，那么它的反码就是 1011 按位取反再在前面加 1，就是 10100\n反码，是没有什么好处滴，看上去它能直接参与运算了，实际上，只要差了个符号，就会有 1 的误差\n问题就在 0 上了，0 的反码即是 00 也可以是 10，所以，就有了补码\n补码 补，就是补，在反码的基础上补一，就是补码（暴论\n这个补，意思是补一，对于负数，给它的反码加个一，就得到了补码\n还是用 -11，-11 的反码是 10100 给它加 1 就是 10101\n这样就算是解决了计算的问题（\n位运算的奇淫技巧 这应该算是本文最核心的内容，在 铺垫了 或者说 水了 478行后开始写 才开始写 的内容，话不多说，切入正题\n判断数字的奇偶 二进制是以二为底的，而偶数则是二的倍数，所以，任何偶数在二进制中末位都是 0，奇数则都是 1，那么只要把数字和 1 作与运算，看看值是 1 还是 0，就有结果了\n举个例子\n1 2 3 11 01011 \u0026amp; 1 00001 1 求整数绝对值 任何一个数右移其补码长度减一得到的结果，就是其符号位填充了整个补码的结果，也就是说，负数一定为 -1，非负数一定为 0，对负数的补码按位取反再加一，得到的就是它的绝对值，而任何数异或 -1 的结果等于它取反。\n对于补码长度为 N 的数 x，其绝对值为(x ^ (x \u0026gt;\u0026gt; N)) - (x \u0026gt;\u0026gt; N)\nLast Date: 2022-09-26T02:17:14+08:00 -\u0026gt; Date: 2022-12-29T01:40:08+08:00\n可算是，写完了，睡觉！\n为什么进制接近e最有效率? - 知乎用户的回答(编辑于 2019-03-09 15:22)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n感谢 Wikipedia 帮查的资料，Mano, M. Morris; Kime, Charles. Logic and Computer Design Fundamentals 4th. Harlow: Pearson. 2014: 13–14. ISBN 978-1-292-02468-4 及 Binary: How Do Computers Talk? 但是这个链接挂了 当然 WebArchive 也没有| Experimonkey. experimonkey.com [2018-12-02].\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n《中华人民共和国法定计量单位》 中的 表5 《用于构成十进倍数和分数单位的词头》 \u0026mdash; 百度百科\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n这其实是逻辑左移的图\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-12-29T01:40:08+08:00","image":"https://blog.dreamonex.eu.org/p/2022/12/bitopt-1/binary_hu4118a7b697a4ce4f0cc2ee52bd40cfca_4625612_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://blog.dreamonex.eu.org/p/2022/12/bitopt-1/","title":"位运算笔记"},{"content":"萌ICP备20229192号\n这一天，或许有很多称呼，是\n公元 2022 年 12 月 23 日 农历 壬寅年 腊月 初一 希吉来历 1444 年 Jumada I-Ula 29 波斯历 1401 年 Dey 2 blabla 这一天，这个 blog 有了这个萌号，先记录一下它最初的样子\n大概明天，或者后天会把它弄的漂亮一点\n这也算是 blog 历史上不大不小的一件 event\n所以博主傻傻的敲下了\n1 t add \u0026#34;@blog +post due:2022-12-25 join moe icp\u0026#34; 也许你不知道这是什么，那正是自然的事情，因为啊，有一个笨蛋博主，早早的就写了 todo，但是他没有 do\nalias t=todo.sh，也许你并不知道 t 是什么，看上下文或许脑子里浮现出了 todo.txt (这是可以戳的，不信你试试) 这个名字，它真的太出色了\n下面是吹水\nThe easiest to-do list I ever used. -Dennis\nBrilliant... the \u0026quot;cool\u0026quot; factor is off the charts. -John\nSo simple, yet also very versatile and flexible. I love it! -mschooler93\nExtremely useful and well executed. -nemof\nNo frills, highly effective and convenient. -Will\n反正，给自己定的期限是 3 天，~~不出所料的拖到了最后~~\n于是在今天 水 了这篇文章\nMoe ICP 当然要先介绍一下 萌备 啊！\nhhhh其实全是博主 cv1 来的 (不要打啊qwq)\n启元 自从某萌主申请了 icp.gov.moe 域名以后\n萌童鞋在百忙中抽空写了个萌备系统\n然后大家看到萌国ICP备案查询系统就上线了\n然后又过了很久很久的时间，某博主又去申请了一个萌备\n萌备的世界 嗯，你没看错，这是萌国的ICP备案。\n萌国在哪呢，听某萌主说，好像是个网络上虚拟的国度。\n反正别问博主了，本博主也是听来的。\n我们说的是萌国ICP备案，号称萌ICP备，简称萌备\n划重点，萌ICP备 非真实 中华人民共和国ICP备案\n萌备的价值观 萌ICP备 纯属萌友网站联萌！\n是一种次元中的爱好，文化的展现。\n若你在万千网站中遇到萌备\n甚有缘分\n申请过程 戳这，戳这，戳这！\n下面请按提示操作(跑)\nPS: 萌号是 四位年份 + 四位自选，所以可以捡个靓号玩玩 =-=\n关于本博客 说完了 萌备，就要说说 咱自己 了\n申请的日期 如前，这个日期是 12 月 23 日，为什么是呢因为在这一天博主突发奇想跑去申请了萌备，所以就是这一天了\n为什么萌号是 20229192 2022 当然是咱申请的年份了 (\n9192 就有一堆话头了，下面是甲乙丙丁时间\n已经是年末了，很多很多很多的靓号已经被选完了，比如6666 年份也是一样，一些有趣的年份也被选去了 很多常数也是一样的情况，比如 $ \\pi $ 和 $ e $ 那么就需要选一个不那么常见的常数了 在 4135 和 9192 间的选择 4135 $$h = 4.135667662(25)\\times 10^{-15} eV \\cdot s$$\n普朗克常数记为 $h$，是一个物理常数，用以描述量子大小。在量子力学中占有重要的角色，马克斯·普朗克在1900年研究物体热辐射的规律时发现，只有假定电磁波的发射和吸收不是连续的，而是一份一份地进行的，计算的结果才能和试验结果是相符。这样的一份能量叫做能量子，每一份能量子等于普朗克常数乘以电磁辐射的频率。2\nkg 是 SI 制中质量的基本单位，其由 普朗克常数，时间，和长度定义，即\n$$1 kg = \\dfrac{h}{6.662607015 \\times 10^{-34}m^{2} \\cdot s^{-1}}$$\n其实普朗克常数在 ISO 标准中的值是 $ h = 6.62607015 \\times 10^{-34} J \\cdot s$，只不过 6626 没了 XD\n9192 $$1s = \\dfrac{9192631770}{\\Delta V_{Cs}}$$\n(将铯-133原子不受扰动的基态超精细能级跃迁频率$\\Delta V_{Cs}$的值固定为9192631770赫兹( $1Hz = 1 s^{-1}$ ))\n秒 是 SI 制中时间的基本单位，铯-133原子不受扰动的基态超精细能级跃迁所对应的辐射的 9192631770 个周期的持续时间为一秒\n最后的选择 最后觉得 9192 比较 重声叠韵 所以就选了 9192 XD，总之，也就加入了萌备\n近况 决定 due: 2022-12-25 有一半原因是为了时效性，另一半原因是为了说明一下自己的近况和计划\ntwice a month ? 一个月两篇 post 成了不可能，最近的折腾是因为疫情被关在了家里 @_@，所以近期会猛发 post，现在已经决定的有\nStack 主题 diy todo.txt 的笔记 jq 的笔记 以前的 post 的英语翻译 子网掩码相关笔记 Linux shell 下的简易 totp 工具 至于能不能写完，那就是另一个故事了 hhhhhh\n一篇还没有写完的 post 看着这个时间，傻傻的博主又一次陷入了沉思2022-09-26T02:17:14+08:00，这是一篇关于位操作的笔记，说了一堆废话，所以至今(三个月)还没有完稿。虽然时间长，但是只写了 400 多行 XD，可能到最后会写到 1500 行吧。学业真是太繁忙了\nLast 呼，写完了，4:09，两个多小时，好耶！睡觉！\n1 2 3 4 5 $ git add --all $ git commit -v -a -S post join moe icp $ git push $ t do x cv 自 萌博客\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n话不能乱说，所以从 Wikipedia 抄了一段来\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-12-25T01:52:08+08:00","image":"https://blog.dreamonex.eu.org/p/2022/12/join-moe-tcp/result_hu1b1f3b6508bbb9a4381cbc7373d0919f_719646_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.dreamonex.eu.org/p/2022/12/join-moe-tcp/","title":"加入萌备"},{"content":"起因 起因肯定是代码和人都不能跑\n经过 发现问题 1 Invalid URL \u0026#34;(\u0026#39;gxxxxm.\u0026#39;, \u0026#39;/xxxxxxx4\u0026#39;)\u0026#34;: No scheme supplied. Perhaps you meant http://(\u0026#39;gxxxxm.\u0026#39;, \u0026#39;/xxxxxxx4\u0026#39;)? 然后\n1 2 3 4 5 6 7 (Pdb) b xx (Pdb) p a_string http://gxxxm.xxxxxx.xx/xxxxxxx4 (Pdb) p a_regex_contains_capture_group re.compile(\u0026#39;https?://([\\\\w\\\\-]+\\\\.)+[\\\\w\\\\-]+(/[\\\\w\\\\-./?%\u0026amp;=]*)?\u0026#39;) (Pdb) p a_regex_contains_capture_group.findall(a_string) (\u0026#39;gxxxxm.\u0026#39;, \u0026#39;/xxxxxxx4\u0026#39;) 研究问题 TL; DR 如果觉得文档晦涩难懂建议直接看人话，请戳 TL; DR\n先是懵逼，不知道过了多久才想起来help(re.findall)\n1 2 3 4 5 6 7 8 findall(pattern, string, flags=0) Return a list of all non-overlapping matches in the string. If one or more capturing groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result. 这里写道：\nIf one or more capturing groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group.\n译为中文 Python Docs 中\nre.findall(pattern, string, flags=0)\n返回 pattern 在 string 中的所有非重叠匹配，以字符串列表或字符串元组列表的形式。对 string 的扫描从左至右，匹配结果按照找到的顺序返回。 空匹配也包括在结果中。\n返回结果取决于模式中捕获组的数量。如果没有组，返回与整个模式匹配的字符串列表。如果有且仅有一个组，返回与该组匹配的字符串列表。如果有多个组，返回与这些组匹配的字符串元组列表。非捕获组不影响结果。\n译为人话 在 Perl风格正则表达式 中被 () 包裹的内容是捕获组，非捕获组包括那四个预查模式以及由 ?: 开头的组。\n如果存在且仅存在一个 捕获组，那么 re.findall 会输出此 捕获组 捕获到的字符串的列表。\n如果存在多个 捕获组，那么 re.findall 就会输出 捕获组 的元组的列表，而不是预期的字符串列表。\n结果 在每一个组里面( i( )的前面加上了?:\n","date":"2022-10-02T00:23:26+08:00","permalink":"https://blog.dreamonex.eu.org/p/2022/10/python-findall/","title":"Python re.findall() 的巨坑"},{"content":"7.23，到学校报道，才拿到录取通知书（小城市的录取通知书都是高中发吗\u0026hellip;），拿到录取通知书，第一件事当然是整活。整什么活呢，第一个想法当然是Github的学生开发包。说干就干！\n选择设备 嗯，这也是个问题，如果使用不支持GPS的设备貌似要在卫星地图上选择学校位置，听说有不少人是在这被坑了~~（感谢前人避坑）~~，所以建议使用手机，另外，建议使用一个正常点的浏览器（比如Kiwi，Firefox，Chrome）\n准备证明资料 如果你的学校提供了edu邮箱，请掠过\n如准考证，学生证，甚至课程表，成绩单。网上教程很多，GitHub给的文档也很 详细（可以看这里）\n更多提示 如果以上资料一个都没有，可以前往教导处要求提供在校证明；另外，一些竞赛的获奖证书也可以用作证明资料\n主要过程 如果你打算申请学生开发包，我相信你已经看过Github的文档了，如果你没看过，就在我上面提到过的文档下面（甚至是同一个页面）（好吧，戳这）\n如果你不知道~~你想干嘛~~这个问题怎么回答 这里是一些参考\nParticipate in open source projects\nPublish open source projects\nParticipate in the open source community\n一般不会太难为你的，如果这里真卡住了，再提交一次\n避坑 坑这东西，前人踩了，就要告诉后人\n证明需要翻译成英语 我就是栽在这里，连栽两次，Github的邮件写的是\nSystem could not translate proof.\n第一次我以为是照片不够清楚，我问了我的某位朋友，证明（对我来说是录取通知书）是否要翻译之后，她说她申请的时候不用，然后我拍的清清楚楚又提交了一次\u0026hellip;结果当然还是：\nSystem could not translate proof.\n人是懵逼的（投诉！投诉！！不公平待遇啊喂）\n两封邮件：\n不要挂梯子 老生常谈了\u0026hellip;，Github会用IP确定你的位置\n上不去？ 上不去怎么办？上不去，上不去，就是上不去，诶嘿就是玩。\n说正经的：\n改host 多逝世 填Form要用英语 老生常谈 这种国际平台肯定是要英语的（人家甚至还是带美利坚的）\n等待通过或失败 1 成功 ? 开始白嫖/吹逼 : 回环往复 Github的动作还是蛮快的（第一次申请是真的压线），第二次两天不到就收到了邮件（当然是失败的），收到邮件的时候是29号的1:01（凌晨），2:23提交了第三次申请，4:17就通过了（哦，好巧，是我生日的日期） 第一件事当然是发个动态吹个逼（\n","date":"2022-08-04T21:17:08+08:00","image":"https://blog.dreamonex.eu.org/p/2022/08/apply-github-student-development-pack/github_hu708e48adc66ab4993a5b7ee02770f72b_18842_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://blog.dreamonex.eu.org/p/2022/08/apply-github-student-development-pack/","title":"白嫖Github学生开发包"},{"content":"准备 备份 网络相关信息（如子网，IP地址，网卡名，网关） 主机名（hostname /etc/hosts） DNS服务器（/etc/resolv.conf） SSH 密钥 Grub配置 硬件信息（/etc/modules.conf） 推荐备份完整的/etc\n思考是否应该手动安装 自动化不一定是脚本小子，只是为了避免不必要的麻烦\nvps2arch 可以全程自动化操作，虽然年久失修 另外，如需lvm你可以直接按上面的脚本或者找别的教程了，原因竟是我没弄过\n我还是不确定行不行，要不你试试吧，寄了别找我\n正式开始 下载Bootstrap （按实际情况修改时间及镜像，可参考Archlinux Downloads）\n1 2 cd /tmp wget https://geo.mirror.pkgbuild.com/iso/xxxx.xx.xx/archlinux-bootstrap-x86_64.tar.gz 校验 1 2 3 wget https://geo.mirror.pkgbuild.com/iso/xxxx.xx.xx/sha256sums.txt cat ... sha256sum 释放bootstrap 1 tar xzf archlinux-bootstrap-*-x86_64.tar.gz --numeric-owner IMPORTANT：编辑/tmp/root.x86_64/etc/pacman.d/mirrorlist选择镜像源\n准备resolv.conf 1 2 rm /tmp/root.x86_64/etc/resolv.conf cp /etc/resolv.conf /tmp/root.x86_64/etc/ 进入chroot 1 2 3 mount --bind /tmp/root.x86_64 /tmp/root.x86_64 mount --bind /boot/efi \u0026#34;/tmp/root.x86_64/boot/efi\u0026#34; # 挂载efi /tmp/root.x86_64/bin/arch-chroot /tmp/root.x86_64/ 若提示FATAL: kernel too old应更新系统内核 若不支持--fork、--pid请参考ArchLinux Wiki，或尝试更新系统 在执行lsblk确认无误后，挂载磁盘，删掉旧系统\n1 2 mount /dev/sda /mnt rm -r ... 若使用LVM，则将对应的逻辑卷挂载到对应的目录，举个例子：mount /dev/lv/root /mnt\nIMPORTANT: 以下目录：/dev, /sys, /run, /tmp, /proc 不应删除 这感觉，简直是rm -rf /*啊\n使用chroot环境 pacman-key 初始化 1 2 pacman-key --init pacman-key --populate archlinux 安装软件包 1 2 3 pacman -Syu pacstrap /mnt base linux linux-firmware pacman -S vim man-pages mandb texinfo grub openssh lvm2 生成fstab 1 genfstab /mnt \u0026gt;\u0026gt; /etc/fstab 本地化 /etc/locale.gen 1 2 en_US.UTF-8 zh_CN.UTF-8 1 locale-gen /etc/locale.conf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 LANG=zh_CN.UTF-8 LANGUAGE=zh_CN.UTF-8:en_US.UTF-8 LC_CTYPE=en_US.UTF-8 LC_NUMERIC=zh_CN.UTF-8 LC_TIME=zh_CN.UTF-8 LC_COLLATE=en_US.UTF-8 LC_MONETARY=zh_CN.UTF-8 LC_MESSAGES=zh_CN.UTF-8 LC_PAPER=zh_CN.UTF-8 LC_NAME=zh_CN.UTF-8 LC_ADDRESS=zh_CN.UTF-8 LC_TELEPHONE=zh_CN.UTF-8 LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=en_US.UTF-8 LC_ALL= 时区 1 2 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # UTC +8 hwclock --systohc 设置密码 1 passwd 开启网络、ssh 编辑/etc/systemd/network/default.network 1 2 3 4 5 6 [Match] Name=eth0 #改为你的网卡名 [Network] Gateway=114.145.114.145 #你的网关 Address=114.145.114.137/24 #你的子网 使用systemd启用服务 1 2 systemctl enable systemd-networkd systemctl enable sshd 准备引导 1 2 3 mount /dev/sda1 /boot/efi grub-install --target=x86_64-efi --efi-directory=/boot/efi grub-mkconfig -o /boot/grub/grub.cfg IMPORTANT：在不支持efi的情况下\n1 grub-install --target=i386-pc --recheck --force /dev/sda Done ! 现在，重启系统，就能看到Arch Linux的字样了\n啥？咋重启，好问题\n怎么重启 先尝试reboot，init 6，shutdown -r等，如果无效（有效才有鬼了）再进行下面的步骤 确保所有数据写入硬盘 1 sync 利用内核参数 激活Magic System Request Key 1 echo 1 \u0026gt; /proc/sys/kernel/sysrq 重启 1 echo \u0026#34;b\u0026#34; \u0026gt; /proc/sysrq-trigger 暴力重启\n包括但不限于，断电，强行关机，服务器控制面板等 参考资料 Arch Linux Wiki Install Arch Linux from existing Linux\n中文页面貌似已过期 Arch Linux Wiki Installation Guide ","date":"2022-07-21T13:55:43+08:00","image":"https://blog.dreamonex.eu.org/p/2022/07/install-arch-from-linux/archlinux_huabecfadfdd744de844b8ea7b92f798ac_30720_120x120_fill_box_smart1_3.png","permalink":"https://blog.dreamonex.eu.org/p/2022/07/install-arch-from-linux/","title":"利用Bootstrap从已有的Linux发行版上安装ArchLinux"},{"content":"其实，编译安装nginx-quic的教程很多，但关于nginx配置有的过时（写于2022-07-14，咱也不能保证这个不会过时对吧），要么很难找到（事实上我就没找到）\n编译安装 1 paru -S nginx-quic ok了，Arch真好\n配置 http/3使用udp，所以需要额外添加一个listen语句\n1 2 listen 443 ssl http2; listen 443 http3 reuseport; IMPORTANT: 一个端口只需要写一次reuseport 举个例子:\n1 2 3 4 5 6 7 8 9 10 11 12 ... server { ... listen 443 http3 reuseport; ... } server { ... listen 443 http3; ... } ... 踩雷时间到 1. 防火墙未放行 443/udp 激动的心，颤抖的手，但是，忘放行了\n1 2 sudo firewall-cmd --zone=public --add-port=443/udp sudo firewall-cmd --zone=public --add-port=443/udp --permanent 2. Alt-Svc标头和QUIC-Status标头 当时按照网上的教程，抄了一个Alt-Svc，用curl检测时，无法发起http/3请求，查了很久找不到资料，然后 灵机一动 找了个支持http/3的网站抄了一个\n部分教程Alt-Svc标头过期，导致无法发起http/3请求\n1 2 add_header Alt-Svc \u0026#39;h3=\u0026#34;:443\u0026#34;; ma=86400\u0026#39;; add_header QUIC-Status $http3; 3. ssl_stapling ignored 特大号巨坑，全网没几篇文章提到，手搓了半天证书，一直没起作用，搞了好久才发现nginx-quic不支持OCSP而不是证书有问题，另外，实际使用中差别并不大，如果有需要可以用OpenSSL编译nginx-quic\nnginx-quic使用BoringSSL，但是nginx的ocsp实现完全基于OpenSSL，所以sudo nginx -t会提示：\n1 \u0026#34;ssl_stapling\u0026#34; ignored, not supported 没特殊需要，不必管它\n最后 检测HTTP/3支持 http3check nginx配置文件生成 NGINXConfig | DigitalOcean ","date":"2022-07-14T21:48:18+08:00","image":"https://blog.dreamonex.eu.org/p/2022/07/nginx-quic/internet_hude5ec0799e6727eb2b0caf20abd48656_209693_120x120_fill_box_smart1_3.png","permalink":"https://blog.dreamonex.eu.org/p/2022/07/nginx-quic/","title":"nginx-quic部署笔记"},{"content":"长长的祝福 十年寒窗苦读，我们早已蓄势待发；十年寒窗苦读，我们早已胸有成竹。让我们用努力诠释梦想，用勇气创造辉煌，让智慧和信念在这骄阳似火的六月闪闪发光。让我们勇往直前，搏击长空，追逐梦想，书写辉煌！\n举胸中豪情，倾满腔热血。与雷霆搏击，同日月争光。\n我们，注定成功。我们，必将辉煌。\n祝所有中高考考生前程似锦，未来可期；愿你们怀着“天生我才必有用”的信心，揣着“铁马冰河入梦来”的决心，带着“横眉冷对千夫指”的勇气，征战考场，一战成名！“长风破浪会有时，直挂云帆济沧海”，愿你们不畏挫折，最终走向理想的高中！\n","date":"2022-06-13T17:52:01+08:00","image":"https://blog.dreamonex.eu.org/p/2022/06/bless-2022/school_hu7bbbd15edbb5f04646106472d28a513b_9643286_120x120_fill_box_smart1_3.png","permalink":"https://blog.dreamonex.eu.org/p/2022/06/bless-2022/","title":"对2022中高考考生的祝福（虽然高考过了"},{"content":"初心使命 开这个博客，主要是分享一些学习，生活的心得 ;-) 很高兴见到你\n先偷个懒，回头再写\n2022年6月8日: 这回头好像有点久啊\u0026hellip;\n2022年6月12日凌晨: 还有两天就要中考了= =，睡不着，把这个写完吧\n2022年6月13日两点：突然发现了hugo和stack，换换换（\n我的情况 大概6.20我中考结束后会开始打理这个博客，毕竟高中了，一个月更新一次就不错了 不过，我还会要求自己一个月两次的\n我的计划 换一个好看的主题 弄一个rss 6月写三篇博文 嗯就这样吧，中考加油！)\n","date":"2022-06-07T00:00:00Z","permalink":"https://blog.dreamonex.eu.org/p/2022/06/hello-world/","title":"Hello World | 博客开张 ;-)"}]